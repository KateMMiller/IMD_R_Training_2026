#### Data structures

We're going to take a little detour into data structures at this point. It'll all tie back in to our tree data.

The data frame we just examined is a type of data structure. A data structure is what it sounds like: it's a structure that holds data in an organized way. There are multiple data structures in R, including vectors, lists, arrays, matrices, data frames, and tibbles (more on this unfortunately-named data structure later). Today we'll focus on vectors and data frames.

<details open><summary class = 'drop'>Vectors</summary>

Vectors are the simplest data structure in R. You can think of vectors as one column of data in an Excel spreadsheet, and the elements are each row in the column. Here are some examples of vectors:

```{r Vectors}
digits <- 0:9  # Use x:y to create a sequence of integers starting at x and ending at y
digits
is_odd <- rep(c(FALSE, TRUE), 5)  # Use rep(x, n) to create a vector by repeating x n times 
is_odd
shoe_sizes <- c(7, 7.5, 8, 8.5, 9, 9.5, 10, 10.5, 11, 11.5)
shoe_sizes
favorite_birds <- c("black-capped chickadee", "dark-eyed junco", "golden-crowned kinglet")
favorite_birds
```

Note the use of `c()`. The `c()` function stands for *combine*, and it combines elements into a single vector. The c() function is a fairly universal way to combine multiple elements in R, and youâ€™re going to see it over and over.

Let's play around with vectors a little more. We can use `is.vector()` to test whether something is a vector. We can get the length of a vector with `length()`. Note that single values in R are just vectors of length one.

```{r Vectors_II}
is.vector(digits)  # Should be TRUE
is.vector(favorite_birds)  # Should also be TRUE

length(digits)  # Hopefully this is 10
length(shoe_sizes)

# Even single values in R are stored as vectors
length_one_chr <- "length one vector"
length_one_int <- 4
is.vector(length_one_chr)
is.vector(length_one_int)
length(length_one_chr)
length(length_one_int)
```

In the examples above, each vector contains a different type of data. `digits` contains integers, `is_odd` contains logical (true/false) values, `favorite_birds` contains text, and shoe_sizes contains decimal numbers. That's because a given vector can only contain a single type of data. 
</details>
</br>

<details open><summary class='drop'>Data Types</summary>
In R, there are four *data types* that we will typically encounter:

  - **character**  Regular text, denoted with double or single quotation marks (e.g. `"hello"`, `"3"`, `"R is my favorite programming language"`)
  - **numeric**  Decimal numbers (e.g. `23`, `3.1415`)
  - **integer**  Integers. If you want to explicitly denote a number as an integer in R, append `L` to it or use `as.integer()` (e.g. `5L`, `as.integer(30)`).
  - **logical**  True or false values (`TRUE`, `FALSE`). Note that `TRUE` and `FALSE` must be all-uppercase.
  
There are two more data types, complex and raw, but you are unlikely to encounter these so we won't cover them here.

You can use the `class()` function to get the data type of a vector:

```{r}
class(favorite_birds)
class(shoe_sizes)
class(digits)
class(is_odd)
```

If you need to access a single element of a vector, you can use the syntax `my_vector[x]` where `x` is the element's *index* (the number corresponding to its position in the vector). You can also use a vector of indices to extract multiple elements from the vector. Note that in R, indexing starts at 1 (i.e. `my_vector[1]` is the first element of `my_vector`). If you've coded in other languages, you may be used to indexing starting at 0.

```{r SubsettingVectors}
second_favorite_bird <- favorite_birds[2]
second_favorite_bird
top_two_birds <- favorite_birds[c(1,2)]
top_two_birds
```

Logical vectors can also be used to subset a vector. The logical vector must be the length of the vector you are subsetting. 

```{r SubsettingVectorsLogical}
odd_digits <- digits[is_odd]
odd_digits
```

</details>
<br>

<details open><summary class = "drop">Data frames</summary>
Let's revisit our wetland data frame. We've explored the data frame as a whole, but it's often useful to look at one column at a time. To do this, we'll use the `$` syntax:

<p class='code'>See list of all sites and species in the wetland data (output truncated at 10 records)</p>
```{r DataFrameColumn, results = 'hide'}
ACAD_wetland$Site_Name
ACAD_wetland$Latin_Name
```

```{r DataFrameColumn, echo = FALSE}
ACAD_wetland$Site_Name[1:10]
ACAD_wetland$Latin_Name[1:10]
```

You can also use square brackets `[]` to access data frame columns. Square brackets are base R's way to view different subsets of your data. I'm only going to touch briefly on this, so you have a basic understanding of how to interpret square brackets. Tomorrow I'll show you much easier ways to subset your data using tidyverse functions. 

Every data frame has 2 dimensions. The first dimension is rows and the second is columns. The code below asks for the dimensions of the ACAD_wetland data frame, and returns 508 11. That means there are 508 rows, and 11 columns. The square brackets allow you to either subset rows, columns, or both at the same time, with rows specified first and columns second.

<p class = 'code'>Return data frame number of rows and columns by checking data frame dimensions</p>
```{r dimdf}
dim(ACAD_wetland)
```

<p class = 'code'>Return first 5 rows of the data frame</p>
```{r rows}
ACAD_wetland[1:5,]
```

<p class = 'code'>Return first 5 rows and a subset of columns of the data frame</p>
```{r rowscols}
ACAD_wetland[1:5, c("Site_Name", "Latin_Name", "Common", "Year", "PctFreq")]
```

You can specify columns by name or by index (integer indicating position of column). It's almost always best to refer to columns by name when possible because it makes your code easier to read and prevents your code from breaking if columns get reordered. But, in case you come across code with numbers in the column part of the brackets, here's what it looks like. Note the empty space to the left of the comma. That means you want all rows, but only the first 4 columns. 

<p class = 'code'>Return all rows and first 4 columns of the data frame</p>
```{r rowscols}
ACAD_sub <- ACAD_wetland[ , 1:4] # works, but risky
ACAD_sub2 <- 
  ACAD_wetland[,c("Site_Name", "Site_Type", "Latin_Name", "Common")] #same result, but better

# compare the two data frames to the original
head(ACAD_wetland)
head(ACAD_sub)
head(ACAD_sub2)
```

</details>
<br>

<details open><summary class = 'drop'>Advanced bracketry</summary>
You can do more than just subset by row numbers and column names. A couple more advanced use of brackets are below. Again, this is for exposure, like if you're reading through a StackOverflow post. There are easier ways to subset your data in R, which we will cover on Day 2. Another important point about R is that there are often multiple ways to perform a task. The best code is code that works, is easy to follow, and is unlikely to break (e.g. uses column names instead of numbers). That still means there are typically multiple equally valid approaches. There are other ways to judge good code as you advance, but for now, meeting the 3 

<p class = "code">Filter data so only invasive species = T are returned</p>
```{r inv}
ACAD_wetland$Latin_Name[ACAD_wetland$Invasive == TRUE]
ACAD_wetland[ACAD_wetland$Invasive == TRUE, "Latin_Name"] # equivalent

```

<p class = 'code'>Return only unique species sorted alphabetically.</p>
```{r rows}
sort(unique(ACAD_wetland[, "Latin_Name"]))
sort(unique(ACAD_wetland$Latin_Name)) # equivalent
```

</details>

